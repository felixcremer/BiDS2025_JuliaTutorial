---
title: General introduction to YAXArrays.jl and xmap
engine: julia
---

```{julia}
#| scrolled: true
#| slideshow: {slide_type: skip}
using Pkg
# Pkg.offline()
Pkg.activate(".")
Pkg.instantiate()
```

```{julia}
import Makie: create_dim_conversion

create_dim_conversion(union_typ::Type{Union{Missing,T}}) where {T<:Real} =
    create_dim_conversion(union_typ.b)
```

```{julia}
#| slideshow: {slide_type: subslide}
using DimensionalData, YAXArrays, Zarr, NetCDF
using CairoMakie
```

```{julia}
#| slideshow: {slide_type: subslide}

bucket = "esdl-esdc-v3.0.2"
store = "esdc-16d-2.5deg-46x72x1440-3.0.2.zarr"
bucketpath = "https://s3.bgc-jena.mpg.de:9000/" * bucket * "/" * store
path = joinpath(homedir(), "Daten/") * "bids2025_" * store
ds = open_dataset(zopen(bucketpath,consolidated=true,fill_as_missing=true))
c = Cube(ds)

#c = Cube(joinpath(tutorialdir,"esdc_subset2.zarr"))
```

## The `mapCube` function

is a generalization of mapslices, where you can annotate the exact signature of the function to be applied. For example the computation of the `median` over time can be written using `mapCube`. 
Here one hase to specify the dimension(s) that the user-defined function is going to operate on. For the computation of the median over time the only input dimension is `time` and there are no output dimensions as only a single value is returned. The user defined function passed to `mapCube` always has the signature `f(outputs..., inputs...)` and potentially followd by additional arguments and keyword args. 

## Apply function along single Axis

```{julia}
#| slideshow: {slide_type: subslide}
using Statistics 
function apply_median(xout, xin)
    x = filter(!ismissing, xin)
    x = filter(!isnan,x)
    xout[] = isempty(x) ? missing : median(x)
end
```

```{julia}
#| slideshow: {slide_type: subslide}
medians = xmap(apply_median, c[Variable=Where(contains("temp"))] ⊘ :time)
```

```{julia}
#| slideshow: {slide_type: subslide}
fig, ax, heat = heatmap(medians[Variable=At("air_temperature_2m"), time=1]);
colorbar = Colorbar(fig[1,2], heat)
fig
```

## Apply function on all elements

```{julia}
#| slideshow: {slide_type: subslide}
medians_kelvin = medians .+ 273.15
```

This function is applied lazily and only computed when the data is worked with. This could be requesting the data via `readcubedata`, saving the data to disk or plotting the data. 

```{julia}
#| slideshow: {slide_type: subslide}
fig, ax, heat = heatmap(medians_kelvin[Variable=At("air_temperature_2m"), time=1]);
colorbar = Colorbar(fig[1,2], heat)
fig
```

## Arguments for inner function and output dimensions

Let's make a slightly more complex computation to demonstrate a case where multiple outputs are generated. For examples, imagine we want to normalize every time series (to zero mean and unit variance), but at the same time return the means and variances in a single dataset for later re-use:

## Apply function with multiple output cubes

```{julia}
#| slideshow: {slide_type: subslide}
function norm(ts_out, mean_out, std_out, ts_in)
    x = filter(!ismissing, ts_in)

    tsshort = filter(!isnan,x)
    if isempty(tsshort)
        ts_out .= missing
        mean_out[] = missing
        std_out[] = missing
    else
        mean_out[] = mean(tsshort)
        std_out[] = std(tsshort)
        ts_out .= (ts_in .- mean_out[])./std_out[]
    end
end
```
```{julia}
ts_norm, mean_ts, std_ts = xmap(norm, c ⊘ :time, output = (XOutput(c.time), XOutput(), XOutput()) )
```


```{julia}
#| scrolled: true
#| slideshow: {slide_type: subslide}
fig, ax, heat = heatmap(std_ts[Variable=At("air_temperature_2m"), time=1]);
colorbar = Colorbar(fig[1,2], heat)
fig
```

## Apply function on moving window

```{julia}
#| slideshow: {slide_type: subslide}
function meanfilter(xout, xin)
    if ismissing(xin[2,2])
        xout .= missing
    else
    xout .= mean(skipmissing(xin))
    end
end
```



```{julia}
fig = Figure()
axorg = Axis(fig[1,1])
heatmap!(axorg, mean_ts[Variable=At("air_temperature_2m"), time=1])
```


```{julia}
#| slideshow: {slide_type: subslide}

dlat = dims(c, :lat)
dlon = dims(c, :lon)
# This needs a better interface for within index space
latinterval = MovingIntervals(center=dlat.val, width=3*step(dlat), n=length(dlat), step=step(dlat))
loninterval = MovingIntervals(center=dlon.val, width=3*step(dlon), n=length(dlon), step=step(dlon))
meanwindows = windows(mean_ts, :lat=>latinterval, :lon=>loninterval)
```

```{julia}
filteredmeans = xmap(meanfilter, meanwindows)

axmean = Axis(fig[2,1])
heatmap!(axmean, filteredmeans[Variable=At("air_temperature_2m"), time=1])
```


## Define new output dimensions

```{julia}
#| slideshow: {slide_type: subslide}
gpp = ds.gross_primary_productivity[
        time=Date(2001)..Date(2018,12,31), 
        lon=Near(11.3464),lat=Near(46.4946)]
fig,ax, pl = lines(gpp, label= "Gross Primary Productivity")
fig
```

So far the function applied here were very simple statistics. Just to stress again, that we are running arbitrary Julia code here, so for example if we want to use some package for time series decomposition like `SignalDecomposition.jl`:

```{julia}
#| slideshow: {slide_type: subslide}
using SignalDecomposition
gpp_smooth , gpp_anomalies = readcubedata.(SignalDecomposition.decompose(lookup(gpp, :time), gpp, TimeAnomaly()))
```

```{julia}
#| slideshow: {slide_type: skip}
#function plot_stlres(t, org, stlres)
    fig = Figure()
    axorg = Axis(fig[1,1],title="Original")
    lines!(axorg, gpp, label="Original GPP")
    axsmooth = Axis(fig[2,1], title="Smoothed Data")
    lines!(axsmooth, gpp_smooth, label="GPP Smoothed")
    axanom = Axis(fig[3,1], title="Anomalies")
    lines!(axanom, gpp_anomalies, label="GPP Anomalies")
    #lines!(ax, gpp_smooth, label="GPP Smoothed")
    fig
```


In order to apply this over a full array we define the usual Trio: indims, outdims and the function to be applied. Here we create a new dimension for the output. This means that inside the function the input array `xin` is a vector of length `n_timesteps` and the output is a matrix of size `n_timesteps x 2` 

```{julia}
#| slideshow: {slide_type: subslide}
function decompose_TS(xout, xin)
    any(isnan,xin) && return xout .= missing
    xsmooth, xanom = SignalDecomposition.decompose(xin)
    xout[:,1] = xsmooth
    xout[:,2] = xanom
end
```


```{julia}
#| slideshow: {slide_type: subslide}

gpp_subset = ds.gross_primary_productivity[Variable=At("y"),
        time=Date(2001)..Date(2018,12,31)] 
gpp_sub_decomposed = xmap(decompose_TS, gpp_subset⊘ :time, output = XOutput(gpp_subset.time, Dim{:Scale}(["Seasonal", "Anomalies"])))
```


You see that the resulting array is a 4-dimensional array including the newly created axis.


