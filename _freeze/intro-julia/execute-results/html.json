{
  "hash": "3a3cf9ccab6a957c92c3d2b6a819d539",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Introduction to Julia\"\n---\n\n# Why Julia?\n\n# Basics of Julia programming\n\n::: {#f9fd0b81 .cell execution_count=1}\n``` {.julia .cell-code}\n# Simple math\nx = 5\ny = 2\nx + y\n```\n\n::: {.cell-output .cell-output-display execution_count=2}\n```\n7\n```\n:::\n:::\n\n\n::: {#d60a5e10 .cell execution_count=2}\n``` {.julia .cell-code}\n# Vector math\nx = [1,2,3,4]\ny = [2.5,3.5,1.0,2.9]\nx + y\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```\n4-element Vector{Float64}:\n 3.5\n 5.5\n 4.0\n 6.9\n```\n:::\n:::\n\n\n::: {#43638dfa .cell execution_count=3}\n``` {.julia .cell-code}\n# Functions look like math\nf(x) = 2x^2 + sin(x)\nf(5)\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```\n49.04107572533686\n```\n:::\n:::\n\n\n::: {#5583e775 .cell execution_count=4}\n``` {.julia .cell-code}\n# Apply a function element-wise\nf.(x)\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```\n4-element Vector{Float64}:\n  2.8414709848078967\n  8.909297426825681\n 18.14112000805987\n 31.243197504692073\n```\n:::\n:::\n\n\n::: {#4448532c .cell execution_count=5}\n``` {.julia .cell-code}\n# Always be explicit when applying function vectorized\nsin.([1.0,2.0,3.0])\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```\n3-element Vector{Float64}:\n 0.8414709848078965\n 0.9092974268256817\n 0.1411200080598672\n```\n:::\n:::\n\n\n::: {#a9ce789e .cell execution_count=6}\n``` {.julia .cell-code}\n# Matrix math\nm = rand(4,3)\nn = ones(3,5)\nm*n\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```\n4×5 Matrix{Float64}:\n 0.93134  0.93134  0.93134  0.93134  0.93134\n 2.5254   2.5254   2.5254   2.5254   2.5254\n 1.82363  1.82363  1.82363  1.82363  1.82363\n 2.01026  2.01026  2.01026  2.01026  2.01026\n```\n:::\n:::\n\n\n### So what is special about Julia?\n\n::: {#1180b876 .cell execution_count=7}\n``` {.julia .cell-code}\nfunction mysum(x)\n    s = zero(eltype(x))\n    for ix in x\n        s = s+ix\n    end\n    return s\nend\nvec = rand(1000000)\n@time mysum(vec)\n@time mysum(vec)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  0.009618 seconds (3.86 k allocations: 183.891 KiB, 91.81% compilation time)\n  0.000739 seconds (1 allocation: 16 bytes)\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=8}\n```\n499515.0814489908\n```\n:::\n:::\n\n\n## Variables\n\n::: {#7b9f39a5 .cell execution_count=8}\n``` {.julia .cell-code}\n# Variables are names (tags, stickers) for Julia objects\nx = 2\ny = x\nx = 3\nx, y \n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n```\n(3, 2)\n```\n:::\n:::\n\n\n## Data types\n\n### Built-in Data types\n\n::: {#20c41ec8 .cell execution_count=9}\n``` {.julia .cell-code}\n#Numeric data types\nfor T in (UInt8, UInt16, UInt32, UInt64, Int8, Int16, Int32, Int64, \n          Float16, Float32, Float64, ComplexF16, ComplexF32, ComplexF64)\n    @show T(5)\nend\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nT(5) = 0x05\nT(5) = 0x0005\nT(5) = 0x00000005\nT(5) = 0x0000000000000005\nT(5) = 5\nT(5) = 5\nT(5) = 5\nT(5) = 5\nT(5) = Float16(5.0)\nT(5) = 5.0f0\nT(5) = 5.0\nT(5) = Float16(5.0) + Float16(0.0)im\nT(5) = 5.0f0 + 0.0f0im\nT(5) = 5.0 + 0.0im\n```\n:::\n:::\n\n\n::: {#550ff501 .cell execution_count=10}\n``` {.julia .cell-code}\n@show typeof([1,2,3])\n@show typeof([1.0,2.0,3.0])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ntypeof([1, 2, 3]) = Vector{Int64}\ntypeof([1.0, 2.0, 3.0]) = Vector{Float64}\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=11}\n\n::: {.ansi-escaped-output}\n```{=html}\n<pre>Vector{Float64}<span class=\"ansi-bright-black-fg\"> (alias for </span><span class=\"ansi-bright-black-fg\">Array{Float64, 1}</span><span class=\"ansi-bright-black-fg\">)</span></pre>\n```\n:::\n\n:::\n:::\n\n\n### Custom data types\n\n`struct`s are basic types composing several fields into a single object.\n\n::: {#da57910c .cell execution_count=11}\n``` {.julia .cell-code}\nstruct PointF\nx::Float64\ny::Float64\nend\np = PointF(2.0,3.0)\n```\n\n::: {.cell-output .cell-output-display execution_count=12}\n```\nPointF(2.0, 3.0)\n```\n:::\n:::\n\n\nThe fields of a struct may or may not be typed\n\n::: {#c47b1448 .cell execution_count=12}\n``` {.julia .cell-code}\nstruct PointUntyped\nx\ny\nend\np = PointUntyped(2.f0, 3)\n```\n\n::: {.cell-output .cell-output-display execution_count=13}\n```\nPointUntyped(2.0f0, 3)\n```\n:::\n:::\n\n\n::: {#7148b089 .cell execution_count=13}\n``` {.julia .cell-code}\nPointUntyped(\"Hallo\", sin)\n```\n\n::: {.cell-output .cell-output-display execution_count=14}\n```\nPointUntyped(\"Hallo\", sin)\n```\n:::\n:::\n\n\nParametric types can be used to generic specialized code for a variety\nof field types.\n\n::: {#d3b4b580 .cell execution_count=14}\n``` {.julia .cell-code}\nstruct Point{T<:Number}\nx::T\ny::T\nend\np = Point(3.f0,2.f0)\n```\n\n::: {.cell-output .cell-output-display execution_count=15}\n```\nPoint{Float32}(3.0f0, 2.0f0)\n```\n:::\n:::\n\n\n## Loops\n\nLoops are written using the `for` keyword and process any object implementing the [iteration interface](https://docs.julialang.org/en/v1/manual/interfaces/#man-interface-iteration)\n\n::: {#840279a3 .cell execution_count=15}\n``` {.julia .cell-code}\nfor i in 1:3\n    println(i)\nend\n\nfor letter in \"hello\"\n    println(letter)\nend\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1\n2\n3\nh\ne\nl\nl\no\n```\n:::\n:::\n\n\n## Functions\n\nThere are 3 ways to define functions in Julia:\n\nLong form:\n\n::: {#913d1b0e .cell execution_count=16}\n``` {.julia .cell-code}\nfunction f1(x, y)\n    return x+y\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=17}\n```\nf1 (generic function with 1 method)\n```\n:::\n:::\n\n\nNote that the `return` keyword is optional. If it is missing, a function always returns the result of the last statement.\n\nShort form:\n\n::: {#c284a78e .cell execution_count=17}\n``` {.julia .cell-code}\nf2(x, y) = x + y\n```\n\n::: {.cell-output .cell-output-display execution_count=18}\n```\nf2 (generic function with 1 method)\n```\n:::\n:::\n\n\nVery useful for writing short one-liners.\n\nAnonymous functions (similar to lambdas in python), will be important in the Functional Programming section:\n\n::: {#e6a167e4 .cell execution_count=18}\n``` {.julia .cell-code}\nf3 = (x,y) -> x + y\n```\n\n::: {.cell-output .cell-output-display execution_count=19}\n```\n#11 (generic function with 1 method)\n```\n:::\n:::\n\n\nThey all define the same function:\n\n::: {#44d89adc .cell execution_count=19}\n``` {.julia .cell-code}\nf1(1,2) == f2(1,2) == f3(1,2) == 3\n```\n\n::: {.cell-output .cell-output-display execution_count=20}\n```\ntrue\n```\n:::\n:::\n\n\n## Multiple Dispatch\n\nIn object-oriented programming languages methods (behavior) are part of the class namespace itself and can be used to implement generic behavior.\n\n```{python}\nclass Point():\n    def __init__(self,x,y):\n        self.x = x\n        self.y = y\n\n    def abs(self):\n        return self.x*self.x + self.y*self.y\n\np = Point(3,2)\np.abs()\n```\n\nIn Julia, functions are first-class objects and can have multiple methods for different combinations of argument types.\n\n::: {#d4d97bf8 .cell execution_count=20}\n``` {.julia .cell-code}\nabsolute(p::Point) = p.x^2 + p.y^2\n```\n\n::: {.cell-output .cell-output-display execution_count=21}\n```\nabsolute (generic function with 1 method)\n```\n:::\n:::\n\n\nThis defines a new function `absolute` with a single method\n\n::: {#d7e25d48 .cell execution_count=21}\n``` {.julia .cell-code}\nmethods(absolute)\n```\n\n::: {.cell-output .cell-output-display execution_count=22}\n```{=html}\n# 1 method for generic function <b>absolute</b> from \u001b[35mMain\u001b[39m:<ul><li> absolute(p::<b>Point</b>) in Main at In[21]:1</li> </ul>\n```\n:::\n:::\n\n\n::: {#09978560 .cell execution_count=22}\n``` {.julia .cell-code}\n@show absolute(Point(2,3))\n@show absolute(Point(2.0,3.0))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nabsolute(Point(2, 3)) = 13\nabsolute(Point(2.0, 3.0)) = 13.0\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=23}\n```\n13.0\n```\n:::\n:::\n\n\nIn addition to defining new functions, existing functions can be extended to work for our custom data types:\n\n::: {#2b3dd9a5 .cell execution_count=23}\n``` {.julia .cell-code}\nimport Base: +, -, *, /, zero, one, oneunit\n+(p1::Point, p2::Point) = Point(p1.x+p2.x, p1.y+p2.y)\n-(p1::Point, p2::Point) = Point(p1.x-p2.x, p1.y-p2.y)\n*(x::Number, p::Point) = Point(x*p.x, x*p.y)\n/(p::Point,x::Number) = Point(p.x/x,p.y/x)\n-(p::Point) = Point(-p.x,-p.y)\nzero(x::Point{T}) where T = zero(typeof(x))\nzero(::Type{Point{T}}) where T = Point(zero(T),zero(T))\none(x::Point{T}) where T = one(typeof(x))\none(::Type{Point{T}}) where T = Point(one(T),one(T))\nPoint{T}(p::Point) where T = Point{T}(T(p.x),T(p.y))\n```\n:::\n\n\nNow that we have defined some basic math around the Point type we can use a lot of generic behavior:\n\n::: {#a7fc49e1 .cell execution_count=24}\n``` {.julia .cell-code}\n#Create zero matrix of Points\nzeros(Point{Float64},3,2)\n```\n\n::: {.cell-output .cell-output-display execution_count=25}\n```\n3×2 Matrix{Point{Float64}}:\n Point{Float64}(0.0, 0.0)  Point{Float64}(0.0, 0.0)\n Point{Float64}(0.0, 0.0)  Point{Float64}(0.0, 0.0)\n Point{Float64}(0.0, 0.0)  Point{Float64}(0.0, 0.0)\n```\n:::\n:::\n\n\n::: {#5c0adb00 .cell execution_count=25}\n``` {.julia .cell-code}\n#Diagonal matrices\npointvec = (1:3) .* ones(Point{Float64})\n```\n\n::: {.cell-output .cell-output-display execution_count=26}\n```\n3-element Vector{Point{Float64}}:\n Point{Float64}(1.0, 1.0)\n Point{Float64}(2.0, 2.0)\n Point{Float64}(3.0, 3.0)\n```\n:::\n:::\n\n\n::: {#f36f31a5 .cell execution_count=26}\n``` {.julia .cell-code}\nusing LinearAlgebra\ndiagm(0=>pointvec)\n```\n\n::: {.cell-output .cell-output-display execution_count=27}\n```\n3×3 Matrix{Point{Float64}}:\n Point{Float64}(1.0, 1.0)  Point{Float64}(0.0, 0.0)  Point{Float64}(0.0, 0.0)\n Point{Float64}(0.0, 0.0)  Point{Float64}(2.0, 2.0)  Point{Float64}(0.0, 0.0)\n Point{Float64}(0.0, 0.0)  Point{Float64}(0.0, 0.0)  Point{Float64}(3.0, 3.0)\n```\n:::\n:::\n\n\n::: {#078c3a50 .cell execution_count=27}\n``` {.julia .cell-code}\nrand(4,5) * ones(Point{Float64},5,2)\n```\n\n::: {.cell-output .cell-output-display execution_count=28}\n```\n4×2 Matrix{Point{Float64}}:\n Point{Float64}(3.6525, 3.6525)    Point{Float64}(3.6525, 3.6525)\n Point{Float64}(1.78177, 1.78177)  Point{Float64}(1.78177, 1.78177)\n Point{Float64}(3.1139, 3.1139)    Point{Float64}(3.1139, 3.1139)\n Point{Float64}(2.26338, 2.26338)  Point{Float64}(2.26338, 2.26338)\n```\n:::\n:::\n\n\n::: {#cdea2d42 .cell execution_count=28}\n``` {.julia .cell-code}\nrange(Point(-1.0,-2.0),Point(3.0,4.0),length=10)\n```\n\n::: {.cell-output .cell-output-display execution_count=29}\n```\n10-element LinRange{Point{Float64}, Int64}:\n Point{Float64}(-1.0, -2.0), …, Point{Float64}(3.0, 4.0)\n```\n:::\n:::\n\n\n# Package management\n\n# Functional Programming\n\nTransform an array by applying the same function to every element. We can do this using a loop:\n\n::: {#e112c519 .cell execution_count=29}\n``` {.julia .cell-code}\na = rand(100)\nout = similar(a)\nfor i in eachindex(a)\n    out[i] = sqrt(a[i])\nend\nout\n```\n\n::: {.cell-output .cell-output-display execution_count=30}\n```\n100-element Vector{Float64}:\n 0.40569790116115334\n 0.6541065977681604\n 0.977605082277798\n 0.5780201251783924\n 0.7491830123639724\n 0.936679733945372\n 0.7260907590361468\n 0.8372184513833079\n 0.6677264931748974\n 0.9229086178823654\n 0.34001492053987126\n 0.4325306586981604\n 0.6679040937533969\n ⋮\n 0.6950224864425166\n 0.4773870180884778\n 0.4909335780146303\n 0.8143634874384189\n 0.49203816634950226\n 0.7683110927305918\n 0.8420592223664212\n 0.5496051330899939\n 0.7053019796229103\n 0.6023275539163602\n 0.614756998653948\n 0.9303507239941956\n```\n:::\n:::\n\n\nIn the end we \"map\" a function over an array, so the following does the same as our loop defined above. \n\n::: {#74b3e660 .cell execution_count=30}\n``` {.julia .cell-code}\nmap(sqrt,a)\n```\n\n::: {.cell-output .cell-output-display execution_count=31}\n```\n100-element Vector{Float64}:\n 0.40569790116115334\n 0.6541065977681604\n 0.977605082277798\n 0.5780201251783924\n 0.7491830123639724\n 0.936679733945372\n 0.7260907590361468\n 0.8372184513833079\n 0.6677264931748974\n 0.9229086178823654\n 0.34001492053987126\n 0.4325306586981604\n 0.6679040937533969\n ⋮\n 0.6950224864425166\n 0.4773870180884778\n 0.4909335780146303\n 0.8143634874384189\n 0.49203816634950226\n 0.7683110927305918\n 0.8420592223664212\n 0.5496051330899939\n 0.7053019796229103\n 0.6023275539163602\n 0.614756998653948\n 0.9303507239941956\n```\n:::\n:::\n\n\nThere is also the very similar `broadcast` function:\n\n::: {#910b97d7 .cell execution_count=31}\n``` {.julia .cell-code}\nbroadcast(sqrt,a)\n```\n\n::: {.cell-output .cell-output-display execution_count=32}\n```\n100-element Vector{Float64}:\n 0.40569790116115334\n 0.6541065977681604\n 0.977605082277798\n 0.5780201251783924\n 0.7491830123639724\n 0.936679733945372\n 0.7260907590361468\n 0.8372184513833079\n 0.6677264931748974\n 0.9229086178823654\n 0.34001492053987126\n 0.4325306586981604\n 0.6679040937533969\n ⋮\n 0.6950224864425166\n 0.4773870180884778\n 0.4909335780146303\n 0.8143634874384189\n 0.49203816634950226\n 0.7683110927305918\n 0.8420592223664212\n 0.5496051330899939\n 0.7053019796229103\n 0.6023275539163602\n 0.614756998653948\n 0.9303507239941956\n```\n:::\n:::\n\n\nInstead of calling the broadcast function explicitly, most Julia programmers would use the shorthand dot-syntax:\n\n::: {#7a674014 .cell execution_count=32}\n``` {.julia .cell-code}\nsqrt.(a)\n```\n\n::: {.cell-output .cell-output-display execution_count=33}\n```\n100-element Vector{Float64}:\n 0.40569790116115334\n 0.6541065977681604\n 0.977605082277798\n 0.5780201251783924\n 0.7491830123639724\n 0.936679733945372\n 0.7260907590361468\n 0.8372184513833079\n 0.6677264931748974\n 0.9229086178823654\n 0.34001492053987126\n 0.4325306586981604\n 0.6679040937533969\n ⋮\n 0.6950224864425166\n 0.4773870180884778\n 0.4909335780146303\n 0.8143634874384189\n 0.49203816634950226\n 0.7683110927305918\n 0.8420592223664212\n 0.5496051330899939\n 0.7053019796229103\n 0.6023275539163602\n 0.614756998653948\n 0.9303507239941956\n```\n:::\n:::\n\n\nwhich gets translated to the former expression when lowering the code. \n\n## Differences between broadcast and map\n\nFor single-argument functions there is no difference between map and broadcast. However, the functions differe in behavior when mutiple arguments are passed:\n\n::: {#46f7916a .cell execution_count=33}\n``` {.julia .cell-code}\na = [0.1, 0.2, 0.3]\nb = [1.0 2.0 3.0]\n@show size(a)\n@show size(b)\n@show map(+,a,b)\n@show broadcast(+,a,b)\n@show a .+ b\nnothing\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nsize(a) = (3,)\nsize(b) = (1, 3)\nmap(+, a, b) = [1.1, 2.2, 3.3]\nbroadcast(+, a, b) = [1.1 2.1 3.1; 1.2 2.2 3.2; 1.3 2.3 3.3]\na .+ b = [1.1 2.1 3.1; 1.2 2.2 3.2; 1.3 2.3 3.3]\n```\n:::\n:::\n\n\n`map`\n- iterates over all arguments separately, and passing them one by one to the applied function\n- agnostic of array shapes\n\n`broadcast`\n- is dimension-aware\n- matches lengths of arrays along each array dimension\n- expanding dimensions of length 1 or non-existing dimensions at the end\n\nIn most cases one uses broadcast because it is easier to type using the dot-notation.\n\n### `reduce` and `foldl`\n\n::: {#ee3cc84b .cell execution_count=34}\n``` {.julia .cell-code}\nreduce(+,1:10)\n```\n\n::: {.cell-output .cell-output-display execution_count=35}\n```\n55\n```\n:::\n:::\n\n\nWhat is happening behind the scenes?\n\n::: {#997758fc .cell execution_count=35}\n``` {.julia .cell-code}\nfunction myplus(x,y)\n    @show x,y\n    return x+y\nend\nreduce(myplus,1:10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(x, y) = (1, 2)\n(x, y) = (3, 3)\n(x, y) = (6, 4)\n(x, y) = (10, 5)\n(x, y) = (15, 6)\n(x, y) = (21, 7)\n(x, y) = (28, 8)\n(x, y) = (36, 9)\n(x, y) = (45, 10)\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=36}\n```\n55\n```\n:::\n:::\n\n\n`foldl` is very similar to reduce, but with left-associativty guaranteed (all elements of the array will be processed strictly in order), makes parallelization impossible.\n\nExample task: find the longest streak of true values in a Bool array.\n\n::: {#ce0b2d34 .cell execution_count=36}\n``` {.julia .cell-code}\nfunction streak(oldstate,newvalue)\n    maxstreak, currentstreak = oldstate\n    if newvalue #We extend the streak by 1\n        currentstreak += 1\n        maxstreak = max(currentstreak, maxstreak)\n    else\n        currentstreak = 0\n    end\n    return (maxstreak,currentstreak)\nend\nx = rand(Bool,1000)\nfoldl(streak,x,init=(0,0))\n```\n\n::: {.cell-output .cell-output-display execution_count=37}\n```\n(9, 0)\n```\n:::\n:::\n\n\n`mapreduce` and `mapfoldl` combine both `map` and reduce. For example, to compute the sum of squares of a vector one can do:\n\n::: {#bb2e22b3 .cell execution_count=37}\n``` {.julia .cell-code}\nr = rand(1000)\nmapreduce(x->x*x,+,r)\n```\n\n::: {.cell-output .cell-output-display execution_count=38}\n```\n342.00530573304724\n```\n:::\n:::\n\n\nTo compute the longest streak of random numbers larger than 0.9 we could do:\n\n::: {#025d31de .cell execution_count=38}\n``` {.julia .cell-code}\nmapfoldl(>(0.1),streak,r,init=(0,0))\n```\n\n::: {.cell-output .cell-output-display execution_count=39}\n```\n(51, 10)\n```\n:::\n:::\n\n\n# Allocations\n\nLast exercise: In a vector of numbers, count how often a consecutive value is larger than its predecessor. \n\n",
    "supporting": [
      "intro-julia_files"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdn.jsdelivr.net/npm/requirejs@2.3.6/require.min.js\" integrity=\"sha384-c9c+LnTbwQ3aujuU7ULEPVvgLs+Fn6fJUvIGTsuu1ZcCf11fiEubah0ttpca4ntM sha384-6V1/AdqZRWk1KAlWbKBlGhN7VG4iE/yAZcO6NZPMF8od0vukrvr0tg4qY6NSrItx\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js\" integrity=\"sha384-ZvpUoO/+PpLXR1lu4jmpXWu80pZlYUAfxl5NsBMWOEPSjUn/6Z/hRTt8+pR6L4N2\" crossorigin=\"anonymous\" data-relocate-top=\"true\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}