{
  "hash": "6afaa5273ada6067e9962721027fda97",
  "result": {
    "engine": "julia",
    "markdown": "---\ntitle: \"Introduction to Julia\"\n---\n\n# Why Julia?\n\n- Published around 2012 initially developed at MIT\n- Just in Time compiled\n- Optionally typed\n- Gives you the best of C, Matlab and Python\n- Function oriented not object oriented\n- solves the two language problem\n\n# Basics of Julia programming\n\n- Variables\n- struct\n- Boolean Operators and Numeric comparisons\n- Functions\n- Multiple Dispatch\n- Keyword arguments\n- Anonymous Functions\n- Conditionals\n\n\n::: {#2 .cell execution_count=1}\n``` {.julia .cell-code}\n# Simple math\nx = 5\ny = 2\nx + y\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n7\n```\n:::\n:::\n\n\n\n::: {#4 .cell execution_count=1}\n``` {.julia .cell-code}\n# Vector math\nx = [1,2,3,4]\ny = [2.5,3.5,1.0,2.9]\nx + y\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n4-element Vector{Float64}:\n 3.5\n 5.5\n 4.0\n 6.9\n```\n:::\n:::\n\n\n\n::: {#6 .cell execution_count=1}\n``` {.julia .cell-code}\n# Functions look like math\nf(x) = 2x^2 + sin(x)\nf(5)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n49.04107572533686\n```\n:::\n:::\n\n\n\n::: {#8 .cell execution_count=1}\n``` {.julia .cell-code}\n# Apply a function element-wise\nf.(x)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n4-element Vector{Float64}:\n  2.8414709848078967\n  8.909297426825681\n 18.14112000805987\n 31.243197504692073\n```\n:::\n:::\n\n\n\n::: {#10 .cell execution_count=1}\n``` {.julia .cell-code}\n# Always be explicit when applying function vectorized\nsin.([1.0,2.0,3.0])\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n3-element Vector{Float64}:\n 0.8414709848078965\n 0.9092974268256817\n 0.1411200080598672\n```\n:::\n:::\n\n\n\n::: {#12 .cell execution_count=1}\n``` {.julia .cell-code}\n# Matrix math\nm = rand(4,3)\nn = ones(3,5)\nm*n\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n4Ã—5 Matrix{Float64}:\n 2.10274   2.10274   2.10274   2.10274   2.10274\n 0.461203  0.461203  0.461203  0.461203  0.461203\n 0.984686  0.984686  0.984686  0.984686  0.984686\n 1.66137   1.66137   1.66137   1.66137   1.66137\n```\n:::\n:::\n\n\n\n### So what is special about Julia?\n\n::: {#14 .cell execution_count=1}\n``` {.julia .cell-code}\nfunction mysum(x)\n    s = zero(eltype(x))\n    for ix in x\n        s = s+ix\n    end\n    return s\nend\nvec = rand(1000000)\n@time mysum(vec)\n@time mysum(vec)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  0.006841 seconds (3.86 k allocations: 184.781 KiB, 80.55% compilation time)\n  0.000944 seconds (1 allocation: 16 bytes)\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n499992.28060113866\n```\n:::\n:::\n\n\n\n\n## Variables\n\n::: {#16 .cell execution_count=1}\n``` {.julia .cell-code}\n# Variables are names (tags, stickers) for Julia objects\nx = 2\ny = x\nx = 3\nx, y\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n(3, 2)\n```\n:::\n:::\n\n\n\n\n\n## Data types\n\n### Built-in Data types\n\n::: {#18 .cell execution_count=1}\n``` {.julia .cell-code}\n#Numeric data types\nfor T in (UInt8, UInt16, UInt32, UInt64, Int8, Int16, Int32, Int64, \n          Float16, Float32, Float64, ComplexF16, ComplexF32, ComplexF64)\n    @show T(5)\nend\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nT(5) = 0x05\nT(5) = 0x0005\nT(5) = 0x00000005\nT(5) = 0x0000000000000005\nT(5) = 5\nT(5) = 5\nT(5) = 5\nT(5) = 5\nT(5) = Float16(5.0)\nT(5) = 5.0f0\nT(5) = 5.0\nT(5) = Float16(5.0) + Float16(0.0)im\nT(5) = 5.0f0 + 0.0f0im\nT(5) = 5.0 + 0.0im\n```\n:::\n:::\n\n\n\n::: {#20 .cell execution_count=1}\n``` {.julia .cell-code}\n@show typeof([1,2,3])\n@show typeof([1.0,2.0,3.0])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ntypeof([1, 2, 3]) = Vector{Int64}\ntypeof([1.0, 2.0, 3.0]) = Vector{Float64}\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=1}\n\n::: {.ansi-escaped-output}\n```{=html}\n<pre>Vector{Float64}<span class=\"ansi-bright-black-fg\"> (alias for </span><span class=\"ansi-bright-black-fg\">Array{Float64, 1}</span><span class=\"ansi-bright-black-fg\">)</span></pre>\n```\n:::\n\n:::\n:::\n\n\n\n### Custom data types\n\n`struct`s are basic types composing several fields into a single object.\n\n::: {#22 .cell execution_count=1}\n``` {.julia .cell-code}\nstruct PointF\n    x::Float64\n    y::Float64\nend\np = PointF(2.0,3.0)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nPointF(2.0, 3.0)\n```\n:::\n:::\n\n\n\nThe fields of a struct may or may not be typed\n\n::: {#24 .cell execution_count=1}\n``` {.julia .cell-code}\nstruct PointUntyped\n    x\n    y\nend\np = PointUntyped(2.f0, 3)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nPointUntyped(2.0f0, 3)\n```\n:::\n:::\n\n\n\n::: {#26 .cell execution_count=1}\n``` {.julia .cell-code}\nPointUntyped(\"Hallo\", sin)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nPointUntyped(\"Hallo\", sin)\n```\n:::\n:::\n\n\n\nParametric types can be used to generic specialized code for a variety\nof field types.\n\n::: {#28 .cell execution_count=1}\n``` {.julia .cell-code}\nstruct Point{T<:Number}\n    x::T\n    y::T\nend\np = Point(3.f0,2.f0)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nPoint{Float32}(3.0f0, 2.0f0)\n```\n:::\n:::\n\n\n\n\n## Loops\n\nLoops are written using the `for` keyword and process any object implementing the [iteration interface](https://docs.julialang.org/en/v1/manual/interfaces/#man-interface-iteration)\n\n::: {#30 .cell execution_count=1}\n``` {.julia .cell-code}\nfor i in 1:3\n    println(i)\nend\n\nfor letter in \"hello\"\n    println(letter)\nend\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1\n2\n3\nh\ne\nl\nl\no\n```\n:::\n:::\n\n\n\n## Functions\n\nThere are 3 ways to define functions in Julia:\n\nLong form:\n\n::: {#32 .cell execution_count=1}\n``` {.julia .cell-code}\nfunction f1(x, y)\n    return x+y\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nf1 (generic function with 1 method)\n```\n:::\n:::\n\n\n\nNote that the `return` keyword is optional. If it is missing, a function always returns the result of the last statement.\n\nShort form:\n\n::: {#34 .cell execution_count=1}\n``` {.julia .cell-code}\nf2(x, y) = x + y\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nf2 (generic function with 1 method)\n```\n:::\n:::\n\n\n\nVery useful for writing short one-liners.\n\nAnonymous functions (similar to lambdas in python), will be important in the Functional Programming section:\n\n::: {#36 .cell execution_count=1}\n``` {.julia .cell-code}\nf3 = (x,y) -> x + y\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n#1 (generic function with 1 method)\n```\n:::\n:::\n\n\n\nThey all define the same function:\n\n::: {#38 .cell execution_count=1}\n``` {.julia .cell-code}\nf1(1,2) == f2(1,2) == f3(1,2) == 3\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\ntrue\n```\n:::\n:::\n\n\n\n## Multiple Dispatch\n\nIn object-oriented programming languages methods (behavior) are part of the class namespace itself and can be used to implement generic behavior.\n\n::: {#40 .cell execution_count=1}\n``` {.julia .cell-code}\nusing PythonCall\n```\n:::\n\n\n\n\n```python\nclass Point():\n    def __init__(self,x,y):\n        self.x = x\n        self.y = y\n\n    def abs(self):\n        return self.x*self.x + self.y*self.y\n\np = Point(3,2)\np.abs()\n\n```\n\n::: {#42 .cell execution_count=1}\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nPython: 13\n```\n:::\n:::\n\n\n\nIn Julia, functions are first-class objects and can have multiple methods for different combinations of argument types.\n\n::: {#44 .cell execution_count=1}\n``` {.julia .cell-code}\nabsolute(p::Point) = p.x^2 + p.y^2\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nabsolute (generic function with 1 method)\n```\n:::\n:::\n\n\n\nThis defines a new function `absolute` with a single method\n\n::: {#46 .cell execution_count=1}\n``` {.julia .cell-code}\nmethods(absolute)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```{=html}\n# 1 method for generic function <b>absolute</b> from \u001b[36mMain.Notebook\u001b[39m:<ul><li> absolute(p::<b>Main.Notebook.Point</b>) in Main.Notebook at <a href=\"https://github.com/felixcremer/BiDS2025_JuliaTutorial/tree/12e8caf0cbfff372ed81b73f81607010fffeefaf//intro-julia.qmd#L218\" target=\"_blank\">/Users/lalonso/Documents/BiDS2025_JuliaTutorial/intro-julia.qmd:218</a></li> </ul>\n```\n:::\n:::\n\n\n\n::: {#48 .cell execution_count=1}\n``` {.julia .cell-code}\n@show absolute(Point(2,3))\n@show absolute(Point(2.0,3.0))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nabsolute(Point(2, 3)) = 13\nabsolute(Point(2.0, 3.0)) = 13.0\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n13.0\n```\n:::\n:::\n\n\n\nIn addition to defining new functions, existing functions can be extended to work for our custom data types:\n\n::: {#50 .cell execution_count=1}\n``` {.julia .cell-code}\nimport Base: +, -, *, /, zero, one, oneunit\n+(p1::Point, p2::Point) = Point(p1.x+p2.x, p1.y+p2.y)\n-(p1::Point, p2::Point) = Point(p1.x-p2.x, p1.y-p2.y)\n*(x::Number, p::Point) = Point(x*p.x, x*p.y)\n/(p::Point,x::Number) = Point(p.x/x,p.y/x)\n-(p::Point) = Point(-p.x,-p.y)\nzero(x::Point{T}) where T = zero(typeof(x))\nzero(::Type{Point{T}}) where T = Point(zero(T),zero(T))\none(x::Point{T}) where T = one(typeof(x))\none(::Type{Point{T}}) where T = Point(one(T),one(T))\nPoint{T}(p::Point) where T = Point{T}(T(p.x),T(p.y))\n```\n:::\n\n\n\nNow that we have defined some basic math around the Point type we can use a lot of generic behavior:\n\n::: {#52 .cell execution_count=1}\n``` {.julia .cell-code}\n#Create zero matrix of Points\nzeros(Point{Float64},3,2)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n3Ã—2 Matrix{Point{Float64}}:\n Point{Float64}(0.0, 0.0)  Point{Float64}(0.0, 0.0)\n Point{Float64}(0.0, 0.0)  Point{Float64}(0.0, 0.0)\n Point{Float64}(0.0, 0.0)  Point{Float64}(0.0, 0.0)\n```\n:::\n:::\n\n\n\n::: {#54 .cell execution_count=1}\n``` {.julia .cell-code}\n#Diagonal matrices\npointvec = (1:3) .* ones(Point{Float64})\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n3-element Vector{Point{Float64}}:\n Point{Float64}(1.0, 1.0)\n Point{Float64}(2.0, 2.0)\n Point{Float64}(3.0, 3.0)\n```\n:::\n:::\n\n\n\n::: {#56 .cell execution_count=1}\n``` {.julia .cell-code}\nusing LinearAlgebra\ndiagm(0=>pointvec)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n3Ã—3 Matrix{Point{Float64}}:\n Point{Float64}(1.0, 1.0)  Point{Float64}(0.0, 0.0)  Point{Float64}(0.0, 0.0)\n Point{Float64}(0.0, 0.0)  Point{Float64}(2.0, 2.0)  Point{Float64}(0.0, 0.0)\n Point{Float64}(0.0, 0.0)  Point{Float64}(0.0, 0.0)  Point{Float64}(3.0, 3.0)\n```\n:::\n:::\n\n\n\n::: {#58 .cell execution_count=1}\n``` {.julia .cell-code}\nrand(4,5) * ones(Point{Float64},5,2)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n4Ã—2 Matrix{Point{Float64}}:\n Point{Float64}(2.77515, 2.77515)  Point{Float64}(2.77515, 2.77515)\n Point{Float64}(3.42832, 3.42832)  Point{Float64}(3.42832, 3.42832)\n Point{Float64}(2.55391, 2.55391)  Point{Float64}(2.55391, 2.55391)\n Point{Float64}(1.60603, 1.60603)  Point{Float64}(1.60603, 1.60603)\n```\n:::\n:::\n\n\n\n::: {#60 .cell execution_count=1}\n``` {.julia .cell-code}\nrange(Point(-1.0,-2.0),Point(3.0,4.0),length=10)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n10-element LinRange{Point{Float64}, Int64}:\n Point{Float64}(-1.0, -2.0), â€¦, Point{Float64}(3.0, 4.0)\n```\n:::\n:::\n\n\n\n\n\n# Package management\n\n# Functional Programming\n\nTransform an array by applying the same function to every element. We can do this using a loop:\n\n::: {#62 .cell execution_count=1}\n``` {.julia .cell-code}\na = rand(100)\nout = similar(a)\nfor i in eachindex(a)\n    out[i] = sqrt(a[i])\nend\nout\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n100-element Vector{Float64}:\n 0.9600521482297211\n 0.6526420528851079\n 0.6917260533942913\n 0.9409432647567283\n 0.9442237519837718\n 0.8808711985915347\n 0.8231046779286021\n 0.5391330544108317\n 0.651259492779308\n 0.1929081604917568\n â‹®\n 0.230333791329993\n 0.5099496064482936\n 0.8657590303781428\n 0.8506088285947234\n 0.6936973349217656\n 0.9629776168316614\n 0.7255792468365476\n 0.5129811381500429\n 0.726308818744019\n```\n:::\n:::\n\n\n\nIn the end we \"map\" a function over an array, so the following does the same as our loop defined above.\n\n::: {#64 .cell execution_count=1}\n``` {.julia .cell-code}\nmap(sqrt,a)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n100-element Vector{Float64}:\n 0.9600521482297211\n 0.6526420528851079\n 0.6917260533942913\n 0.9409432647567283\n 0.9442237519837718\n 0.8808711985915347\n 0.8231046779286021\n 0.5391330544108317\n 0.651259492779308\n 0.1929081604917568\n â‹®\n 0.230333791329993\n 0.5099496064482936\n 0.8657590303781428\n 0.8506088285947234\n 0.6936973349217656\n 0.9629776168316614\n 0.7255792468365476\n 0.5129811381500429\n 0.726308818744019\n```\n:::\n:::\n\n\n\nThere is also the very similar `broadcast` function:\n\n::: {#66 .cell execution_count=1}\n``` {.julia .cell-code}\nbroadcast(sqrt,a)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n100-element Vector{Float64}:\n 0.9600521482297211\n 0.6526420528851079\n 0.6917260533942913\n 0.9409432647567283\n 0.9442237519837718\n 0.8808711985915347\n 0.8231046779286021\n 0.5391330544108317\n 0.651259492779308\n 0.1929081604917568\n â‹®\n 0.230333791329993\n 0.5099496064482936\n 0.8657590303781428\n 0.8506088285947234\n 0.6936973349217656\n 0.9629776168316614\n 0.7255792468365476\n 0.5129811381500429\n 0.726308818744019\n```\n:::\n:::\n\n\n\nInstead of calling the broadcast function explicitly, most Julia programmers would use the shorthand dot-syntax:\n\n::: {#68 .cell execution_count=1}\n``` {.julia .cell-code}\nsqrt.(a)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n100-element Vector{Float64}:\n 0.9600521482297211\n 0.6526420528851079\n 0.6917260533942913\n 0.9409432647567283\n 0.9442237519837718\n 0.8808711985915347\n 0.8231046779286021\n 0.5391330544108317\n 0.651259492779308\n 0.1929081604917568\n â‹®\n 0.230333791329993\n 0.5099496064482936\n 0.8657590303781428\n 0.8506088285947234\n 0.6936973349217656\n 0.9629776168316614\n 0.7255792468365476\n 0.5129811381500429\n 0.726308818744019\n```\n:::\n:::\n\n\n\nwhich gets translated to the former expression when lowering the code. \n\n## Differences between broadcast and map\n\nFor single-argument functions there is no difference between map and broadcast. However, the functions differe in behavior when mutiple arguments are passed:\n\n::: {#70 .cell execution_count=1}\n``` {.julia .cell-code}\na = [0.1, 0.2, 0.3]\nb = [1.0 2.0 3.0]\n@show size(a)\n@show size(b)\n@show map(+,a,b)\n@show broadcast(+,a,b)\n@show a .+ b\nnothing\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nsize(a) = (3,)\nsize(b) = (1, 3)\nmap(+, a, b) = [1.1, 2.2, 3.3]\nbroadcast(+, a, b) = [1.1 2.1 3.1; 1.2 2.2 3.2; 1.3 2.3 3.3]\na .+ b = [1.1 2.1 3.1; 1.2 2.2 3.2; 1.3 2.3 3.3]\n```\n:::\n:::\n\n\n\n`map`\n- iterates over all arguments separately, and passing them one by one to the applied function\n- agnostic of array shapes\n\n`broadcast`\n- is dimension-aware\n- matches lengths of arrays along each array dimension\n- expanding dimensions of length 1 or non-existing dimensions at the end\n\nIn most cases one uses broadcast because it is easier to type using the dot-notation.\n\n### `reduce` and `foldl`\n\n::: {#72 .cell execution_count=1}\n``` {.julia .cell-code}\nreduce(+,1:10)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n55\n```\n:::\n:::\n\n\n\nWhat is happening behind the scenes?\n\n::: {#74 .cell execution_count=1}\n``` {.julia .cell-code}\nfunction myplus(x,y)\n    @show x,y\n    return x+y\nend\nreduce(myplus,1:10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(x, y) = (1, 2)\n(x, y) = (3, 3)\n(x, y) = (6, 4)\n(x, y) = (10, 5)\n(x, y) = (15, 6)\n(x, y) = (21, 7)\n(x, y) = (28, 8)\n(x, y) = (36, 9)\n(x, y) = (45, 10)\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n55\n```\n:::\n:::\n\n\n\n`foldl` is very similar to reduce, but with left-associativty guaranteed (all elements of the array will be processed strictly in order), makes parallelization impossible.\n\nExample task: find the longest streak of true values in a Bool array.\n\n::: {#76 .cell execution_count=1}\n``` {.julia .cell-code}\nfunction streak(oldstate,newvalue)\n    maxstreak, currentstreak = oldstate\n    if newvalue #We extend the streak by 1\n        currentstreak += 1\n        maxstreak = max(currentstreak, maxstreak)\n    else\n        currentstreak = 0\n    end\n    return (maxstreak,currentstreak)\nend\nx = rand(Bool,1000)\nfoldl(streak,x,init=(0,0))\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n(8, 0)\n```\n:::\n:::\n\n\n\n`mapreduce` and `mapfoldl` combine both `map` and reduce. For example, to compute the sum of squares of a vector one can do:\n\n::: {#78 .cell execution_count=1}\n``` {.julia .cell-code}\nr = rand(1000)\nmapreduce(x->x*x,+,r)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n340.7118723795464\n```\n:::\n:::\n\n\n\nTo compute the longest streak of random numbers larger than 0.9 we could do:\n\n::: {#80 .cell execution_count=1}\n``` {.julia .cell-code}\nmapfoldl(>(0.1),streak,r,init=(0,0))\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n(64, 8)\n```\n:::\n:::\n\n\n\n# Allocations\n\nLast exercise: In a vector of numbers, count how often a consecutive value is larger than its predecessor.\n\n",
    "supporting": [
      "intro-julia_files"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\" data-relocate-top=\"true\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}